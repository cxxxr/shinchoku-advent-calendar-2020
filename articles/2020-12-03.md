# SBCLの改行コードをなんとかしようとした黒歴史

この記事は[進捗 Advent Calendar 2020](https://github.com/t-sin/shinchoku-advent-calendar-2020)の3日目の記事です。

今日は手短にいきます。

## なにをしようとしたんですか

SBCLにおいて以下の2点をやろうとしました:

- プラットフォームに関係なく、ストリームを開くときに改行コード (CR, LF, CRLF) を指定できるようにする
- 処理系は指定された改行コードでテキストストリームを処理できるようになる

[リポジトリはこちら](https://github.com/t-sin/sbcl-external-format-eol)。4年くらい前のことだそうです。

## 何が問題だったんですか

ひとえにSBCLが改行コードについてプラットフォーム依存な認識をすることが不満でした。

Common Lispのオープンソースな処理系で[Steel Bank Common Lisp (SBCL)](http://www.sbcl.org/)という処理系があります。有名な処理系なのでいまだとCommon Lispを触ろうとして1、2番目くらいに触れる処理系なんじゃないかと思います。コンパイラが速いコードを生成するし、オープンソースですし、そこそこ機能も揃っていて開発もアクティブなので、いちばんメジャーな処理系です。

Common Lispではファイルストリーム等を開くときに、外部のエンコーディング等を指示する指定子 (Common Lisp用語で[external file format](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_e.htm#external_file_format)) というのがありますが、このexternal formatに何を指定できるかは処理系依存です。つまり、処理系によってどんなエンコーディングを扱えるのかが変わってくるというわけです。SBCLでは、改行コードに関することはexternal formatに指定できません。

また、Common Lispでは「改行を表わす文字」が仕様で決められています (`#\newline`という文字です)。現実ではよく「改行コードは1つではないので対象のプラットフォームに合った改行コードに変換してデータを送りましょう」と言われることもあると思いますが、ご存知の通り現在使われている改行コードは3つ、CR (mac) と LF (Unix系OS) と CRLF (Windows) があります。Common Lispの`#\newline`がこれらのどの文字に対応するかは各処理系が決めることです。ちなみにSBCLでは、動作するプラットフォームによって`#\newline`と認識される改行コードが異なります (その違いがどこからやってくるのかはぼくには未知です)。

これでどういう問題が起こるかというと、Windowsで作成したテキストファイル (改行コードはCRLF) をたとえばubuntu上のSBCL (改行コードはLF) で開いて読み込むと、LFは`#\newline`になりますが、CRは`#\return`という文字になります。プログラムを書く側としては、せめてexternal formatに改行コードを指定することができれば、改行コードの判定を行うなどした後にこちらで指定して正しく読み取ることが可能です。実際[Clozure Common Lisp](https://ccl.clozure.com/)においては改行コードを指定可能なので前述のような対策を取ることができます。

この点がぼくのSBCLに対する不満点でした。

## それで？

それで調査をしていたのがあのリポジトリです。SBCLのファイル入出力の部分とexternal formatの処理をする部分を書き換えてやれば、望みの対応ができるんじゃないかなあと。もちろんこれは失敗に終わります。言語処理系のしくみすらよくわかってなかった当時、それはぼくの手に余りました。収穫はといえば、SBCLをビルドするには別のCommon Lisp処理系が必要ということくらいでした。

いまならそういう用途のときはClozure CLを使うことにしています。解決！！
